{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Hi I am Kevin Saji</code>","text":"<p>About Me</p> <p>Hi! My name is Kevin Saji, and I\u2019m a student at SRM Kattanakulathur. I was born in Kerala and raised in Bangalore and have always been interested in sports and video games. When I was younger, I would participate in out-door activities all day\u2014and it wasn\u2019t just for fun! It was because I\u2019ve always loved playing football and kabaddi. I think they\u2019re so fun and helped me bond with people . And the best part is that they help in keeping my body very active and healthy. I\u2019ve been working on a portfolio since high school but never finished it until recently. Now that I\u2019m done with classes for this semester, I hope you\u2019ll take a look at it!</p>"},{"location":"dsa/","title":"DSA portfolio","text":""},{"location":"dsa/#insertion-in-circular-linked-lists","title":"Insertion in Circular Linked Lists","text":"<p> <pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nstruct Node\n{\n  int data;\n  struct Node *next;\n};\nvoid insertStart (struct Node **head, int data)\n{\n  struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));\n  newNode-&gt;data = data;\n\n  // if its the first node being entered\n  if (*head == NULL)\n    {\n      *head = newNode;\n      (*head)-&gt;next = *head;\n      return;\n    }\n\n  // if LL already as &gt;=1 node\n  struct Node *curr = *head;\n\n  // traverse till last node in LL\n  while (curr-&gt;next != *head)\n    {\n      curr = curr-&gt;next;\n    }\n  // assign LL's last node's next as this new node\n  curr-&gt;next = newNode;\n\n  // assign newNode's next as current head\n  newNode-&gt;next = *head;\n\n  // change head to this new node\n  *head = newNode;\n}\n\nvoid insertLast (struct Node **head, int data)\n{\n  struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));\n  newNode-&gt;data = data;\n\n  // if its the first node being entered\n  if (*head == NULL)\n    {\n      *head = newNode;\n      (*head)-&gt;next = *head;\n      return;\n    }\n\n  // if LL already as &gt;=1 node\n  struct Node *curr = *head;\n\n  // traverse till last node in LL\n  while (curr-&gt;next != *head)\n    {\n      curr = curr-&gt;next;\n    }\n\n  // assign LL's current last node's next as this new node\n  curr-&gt;next = newNode;\n\n  // assign this new node's next as current head of LL\n  newNode-&gt;next = *head;\n}\n\nint getCurrSize (struct Node *node)\n{\n  int size = 0;\n\n  while (node != NULL)\n    {\n      node = node-&gt;next;\n      size++;\n    }\n  return size;\n}\n\nvoid insertPosition (int data, int pos, struct Node **head) \n//function to insert element at specific position\n{\n  struct Node *newnode, *curNode;\n  int i;\n\n  if (*head == NULL)\n    {\n      printf (\"List is empty\");\n    }\n  if (pos == 1)\n    {\n      insertStart (head, data);\n      return;\n    }\n  else\n    {\n      newnode = (struct Node *) malloc (sizeof (struct Node));\n      newnode-&gt;data = data;\n      curNode = *head;\n      while (--pos &gt; 1)\n    {\n      curNode = curNode-&gt;next;\n    }\n      newnode-&gt;next = curNode-&gt;next;\n      curNode-&gt;next = newnode;\n    }\n}\n\nvoid display (struct Node *head)\n{\n  // if there are no node in LL\n  if (head == NULL)\n    return;\n\n  struct Node *temp = head;\n\n  //need to take care of circular structure of LL\n  do\n    {\n      printf (\"%d \", temp-&gt;data);\n      temp = temp-&gt;next;\n\n    }\n  while (temp != head);\n  printf (\"\\n\");\n}\n\nint main ()\n{\n\n  struct Node *head = NULL;\n\n  printf(\"Insert at beginning: \");\n  insertStart (&amp;head, 2);\n  insertStart (&amp;head, 1);\n  display (head);\n\n  printf(\"Insert at End: \");\n  insertLast (&amp;head, 30);\n  insertLast (&amp;head, 40);\n  display (head);\n\n  printf(\"Insert at Specific Position: \");\n  insertPosition (5, 3, &amp;head);\n  display (head);\n\n  return 0;\n}\n</code></pre></p>"},{"location":"dsa/#deletion-in-circular-linked-lists","title":"Deletion in Circular Linked Lists","text":"<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n// structure for Circular Linked List\nstruct Node\n{\n  int data;\n  struct Node *next;\n};\n\nint calcSize (struct Node *head);\n\nvoid deleteBegin (struct Node **head)\n{\n\n  struct Node *tempNode = *head;\n\n  // if there are no nodes in Linked List can't delete\n  if (*head == NULL)\n    {\n      printf (\"Linked List Empty, nothing to delete\");\n      return;\n    }\n\n  // if only 1 node in CLL\n  if (tempNode-&gt;next == *head)\n    {\n      *head = NULL;\n      return;\n    }\n\n  struct Node *curr = *head;\n\n  // traverse till last node in CLL\n  while (curr-&gt;next != *head)\n    curr = curr-&gt;next;\n\n  // assign last node's next to 2nd node in CLL\n  curr-&gt;next = (*head)-&gt;next;\n\n  // move head to next node\n  *head = (*head)-&gt;next;\n  free (tempNode);\n}\n\nvoid deleteEnd (struct Node **head)\n{\n  struct Node *tempNode = *head;\n  struct Node *previous;\n\n  // if there are no nodes in Linked List can't delete\n  if (*head == NULL)\n    {\n      printf (\"Linked List Empty, nothing to delete\");\n      return;\n    }\n\n  // if Linked List has only 1 node\n  if (tempNode-&gt;next == *head)\n    {\n      *head = NULL;\n      return;\n    }\n\n  // else traverse to the last node\n  while (tempNode-&gt;next != *head)\n    {\n      // store previous link node as we need to change its next val\n      previous = tempNode;\n      tempNode = tempNode-&gt;next;\n    }\n  // Curr assign 2nd last node's next to head\n  previous-&gt;next = *head;\n  // delete the last node\n  free (tempNode);\n  // 2nd last now becomes the last node\n}\n\nvoid deletePos (struct Node **head, int n)\n{\n\n  int size = calcSize (*head);\n\n  if (n &lt; 1 || size &lt; n)\n    {\n      printf (\"Can't delete, %d is not a valid position\\n\", n);\n    }\n  else if (n == 1)\n    deleteBegin (head);\n  else if (n == size)\n    deleteEnd (head);\n  else\n    {\n      struct Node *tempNode = *head;\n      struct Node *previous;    // traverse to the nth node\n      while (--n)\n    { // store previous link node as we need to change its next val \n      previous = tempNode;\n      tempNode = tempNode-&gt;next;\n    }\n\n      // change previous node's next node to nth node's next node\n      previous-&gt;next = tempNode-&gt;next;\n      // delete this nth node\n      free (tempNode);\n    }\n}\n\nvoid insert (struct Node **head, int data)\n{\n  struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));\n  newNode-&gt;data = data;\n\n  if (*head == NULL)\n    {\n      *head = newNode;\n      (*head)-&gt;next = *head;\n      return;\n    }\n\n  struct Node *curr = *head;\n\n  while (curr-&gt;next != *head)\n    {\n      curr = curr-&gt;next;\n    }\n\n  curr-&gt;next = newNode;\n  newNode-&gt;next = *head;\n  *head = newNode;\n}\n\nint calcSize (struct Node *head)\n{\n  int size = 0;\n  struct Node *temp = head;\n\n  if (temp == NULL)\n    return size;\n\n  do\n    {\n      size++;\n      temp = temp-&gt;next;\n\n    }\n  while (temp != head);\n\n  return size;\n}\n\nvoid display (struct Node *head)\n{\n  // if there are no node in CLL\n  if (head == NULL)\n    return;\n\n  struct Node *temp = head;\n\n  //need to take care of circular structure of CLL\n  do\n    {\n      printf (\"%d \", temp-&gt;data);\n      temp = temp-&gt;next;\n\n    }\n  while (temp != head);\n  printf (\"\\n\");\n}\n\nint main ()\n{\n\n  // first node will be null at creation    \n  struct Node *head = NULL;\n\n  insert (&amp;head, 10);\n  insert (&amp;head, 11);\n  insert (&amp;head, 12);\n  insert (&amp;head, 13);\n  insert (&amp;head, 14);\n  insert (&amp;head, 15);\n  insert (&amp;head, 16);\n\n  display (head);\n\n  deleteBegin (&amp;head);\n  display (head);\n\n  deleteEnd (&amp;head);\n  display (head);\n\n  deletePos (&amp;head, 3);\n  display (head);\n\n  return 0;\n}\n</code></pre>"},{"location":"dsa/#traversal-of-circular-linked-lists","title":"Traversal of Circular Linked lists","text":"<p> <pre><code>/* Function to traverse a given Circular linked list and print nodes */\nvoid printList(struct Node *first)\n{\n    struct Node *temp = first; \n\n    // If linked list is not empty\n    if (first != NULL) \n    {\n        // Keep printing nodes till we reach the first node again\n        do\n        {\n            printf(\"%d \", temp-&gt;data);\n            temp = temp-&gt;next;\n        }\n        while (temp != first);\n    }\n}\n</code></pre></p>"},{"location":"dsa/#insertion-in-doubly-circular-linked-lists","title":"Insertion in Doubly Circular Linked Lists","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning of the list\nvoid insertAtBeginning(struct Node** head, int data) {\n    struct Node* newNode = createNode(data);\n    if (*head == NULL) {\n        newNode-&gt;next = newNode;\n        newNode-&gt;prev = newNode;\n        *head = newNode;\n    } else {\n        newNode-&gt;next = *head;\n        newNode-&gt;prev = (*head)-&gt;prev;\n        (*head)-&gt;prev-&gt;next = newNode;\n        (*head)-&gt;prev = newNode;\n        *head = newNode;\n    }\n}\n\n// Function to insert a node at the end of the list\nvoid insertAtEnd(struct Node** head, int data) {\n    if (*head == NULL) {\n        insertAtBeginning(head, data);\n        return;\n    }\n    struct Node* newNode = createNode(data);\n    newNode-&gt;next = *head;\n    newNode-&gt;prev = (*head)-&gt;prev;\n    (*head)-&gt;prev-&gt;next = newNode;\n    (*head)-&gt;prev = newNode;\n}\n\n// Function to insert a node at the middle of the list\nvoid insertAtMiddle(struct Node** head, int data, int position) {\n    if (position &lt;= 0) {\n        printf(\"Invalid position\\n\");\n        return;\n    }\n    if (position == 1) {\n        insertAtBeginning(head, data);\n        return;\n    }\n    struct Node* newNode = createNode(data);\n    struct Node* current = *head;\n    for (int i = 1; i &lt; position - 1 &amp;&amp; current-&gt;next != *head; i++) {\n        current = current-&gt;next;\n    }\n    if (current-&gt;next == *head) {\n        printf(\"Position out of range\\n\");\n        return;\n    }\n    newNode-&gt;next = current-&gt;next;\n    newNode-&gt;prev = current;\n    current-&gt;next-&gt;prev = newNode;\n    current-&gt;next = newNode;\n}\n\n// Function to display the list\nvoid displayList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Node* head = NULL;\n\n    // Inserting nodes\n    insertAtBeginning(&amp;head, 10);\n    insertAtEnd(&amp;head, 20);\n    insertAtMiddle(&amp;head, 15, 2);\n\n    // Displaying the list\n    printf(\"Doubly Circular Linked List: \");\n    displayList(head);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"dsa/#deletion-in-doubly-circular-linked-lists","title":"Deletion in Doubly Circular Linked Lists","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning of the list\nvoid insertAtBeginning(struct Node** head, int data) {\n    struct Node* newNode = createNode(data);\n    if (*head == NULL) {\n        newNode-&gt;next = newNode;\n        newNode-&gt;prev = newNode;\n        *head = newNode;\n    } else {\n        newNode-&gt;next = *head;\n        newNode-&gt;prev = (*head)-&gt;prev;\n        (*head)-&gt;prev-&gt;next = newNode;\n        (*head)-&gt;prev = newNode;\n        *head = newNode;\n    }\n}\n\n// Function to delete a node from the beginning of the list\nvoid deleteFromBeginning(struct Node** head) {\n    if (*head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* temp = *head;\n    if ((*head)-&gt;next == *head) {\n        *head = NULL;\n    } else {\n        (*head)-&gt;prev-&gt;next = (*head)-&gt;next;\n        (*head)-&gt;next-&gt;prev = (*head)-&gt;prev;\n        *head = (*head)-&gt;next;\n    }\n    free(temp);\n}\n\n// Function to delete a node from the end of the list\nvoid deleteFromEnd(struct Node** head) {\n    if (*head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* temp = (*head)-&gt;prev;\n    if ((*head)-&gt;next == *head) {\n        *head = NULL;\n    } else {\n        temp-&gt;prev-&gt;next = *head;\n        (*head)-&gt;prev = temp-&gt;prev;\n    }\n    free(temp);\n}\n\n// Function to delete a node from the middle of the list\nvoid deleteFromMiddle(struct Node** head, int position) {\n    if (*head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    if (position &lt;= 0) {\n        printf(\"Invalid position\\n\");\n        return;\n    }\n    if (position == 1) {\n        deleteFromBeginning(head);\n        return;\n    }\n    struct Node* current = *head;\n    for (int i = 1; i &lt; position &amp;&amp; current-&gt;next != *head; i++) {\n        current = current-&gt;next;\n    }\n    if (current-&gt;next == *head) {\n        printf(\"Position out of range\\n\");\n        return;\n    }\n    current-&gt;prev-&gt;next = current-&gt;next;\n    current-&gt;next-&gt;prev = current-&gt;prev;\n    free(current);\n}\n\n// Function to display the list\nvoid displayList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Node* head = NULL;\n\n    // Inserting nodes\n    insertAtBeginning(&amp;head, 10);\n    insertAtBeginning(&amp;head, 20);\n    insertAtBeginning(&amp;head, 30);\n    insertAtBeginning(&amp;head, 40);\n\n    // Displaying the list\n    printf(\"Doubly Circular Linked List: \");\n    displayList(head);\n\n    // Deleting nodes\n    deleteFromBeginning(&amp;head);\n    deleteFromEnd(&amp;head);\n    deleteFromMiddle(&amp;head, 2);\n\n    // Displaying the list after deletion\n    printf(\"Doubly Circular Linked List after deletion: \");\n    displayList(head);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"dsa/#traversal-of-doubly-circular-linked-lists","title":"Traversal of Doubly Circular Linked lists","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning of the list\nvoid insertAtBeginning(struct Node** head, int data) {\n    struct Node* newNode = createNode(data);\n    if (*head == NULL) {\n        newNode-&gt;next = newNode;\n        newNode-&gt;prev = newNode;\n        *head = newNode;\n    } else {\n        newNode-&gt;next = *head;\n        newNode-&gt;prev = (*head)-&gt;prev;\n        (*head)-&gt;prev-&gt;next = newNode;\n        (*head)-&gt;prev = newNode;\n        *head = newNode;\n    }\n}\n\n// Function to traverse and print the doubly circular linked list\nvoid traverseList(struct Node* head) {\n    if (head == NULL) {\n        printf(\"List is empty\\n\");\n        return;\n    }\n    struct Node* current = head;\n    do {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    } while (current != head);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Node* head = NULL;\n\n    // Inserting nodes\n    insertAtBeginning(&amp;head, 10);\n    insertAtBeginning(&amp;head, 20);\n    insertAtBeginning(&amp;head, 30);\n    insertAtBeginning(&amp;head, 40);\n\n    // Displaying the list\n    printf(\"Doubly Circular Linked List: \");\n    traverseList(head);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"dsa/#double-ended-queue-operation","title":"Double Ended Queue Operation","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Structure of a node\nstruct Node {\n    int data;\n    struct Node* next;\n    struct Node* prev;\n};\n\n// Structure of a deque\nstruct Deque {\n    struct Node* front;\n    struct Node* rear;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    newNode-&gt;data = data;\n    newNode-&gt;next = NULL;\n    newNode-&gt;prev = NULL;\n    return newNode;\n}\n\n// Function to initialize a deque\nstruct Deque* initializeDeque() {\n    struct Deque* deque = (struct Deque*)malloc(sizeof(struct Deque));\n    if (deque == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    deque-&gt;front = NULL;\n    deque-&gt;rear = NULL;\n    return deque;\n}\n\n// Function to insert an element at the front of the deque\nvoid insertFront(struct Deque* deque, int data) {\n    struct Node* newNode = createNode(data);\n    if (deque-&gt;front == NULL) {\n        deque-&gt;front = newNode;\n        deque-&gt;rear = newNode;\n    } else {\n        newNode-&gt;next = deque-&gt;front;\n        deque-&gt;front-&gt;prev = newNode;\n        deque-&gt;front = newNode;\n    }\n}\n\n// Function to insert an element at the rear of the deque\nvoid insertRear(struct Deque* deque, int data) {\n    struct Node* newNode = createNode(data);\n    if (deque-&gt;rear == NULL) {\n        deque-&gt;front = newNode;\n        deque-&gt;rear = newNode;\n    } else {\n        newNode-&gt;prev = deque-&gt;rear;\n        deque-&gt;rear-&gt;next = newNode;\n        deque-&gt;rear = newNode;\n    }\n}\n\n// Function to delete an element from the front of the deque\nvoid deleteFront(struct Deque* deque) {\n    if (deque-&gt;front == NULL) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    struct Node* temp = deque-&gt;front;\n    deque-&gt;front = deque-&gt;front-&gt;next;\n    if (deque-&gt;front == NULL) {\n        deque-&gt;rear = NULL;\n    } else {\n        deque-&gt;front-&gt;prev = NULL;\n    }\n    free(temp);\n}\n\n// Function to delete an element from the rear of the deque\nvoid deleteRear(struct Deque* deque) {\n    if (deque-&gt;rear == NULL) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    struct Node* temp = deque-&gt;rear;\n    deque-&gt;rear = deque-&gt;rear-&gt;prev;\n    if (deque-&gt;rear == NULL) {\n        deque-&gt;front = NULL;\n    } else {\n        deque-&gt;rear-&gt;next = NULL;\n    }\n    free(temp);\n}\n\n// Function to display the elements of the deque\nvoid displayDeque(struct Deque* deque) {\n    if (deque-&gt;front == NULL) {\n        printf(\"Deque is empty\\n\");\n        return;\n    }\n    struct Node* current = deque-&gt;front;\n    while (current != NULL) {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    }\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    struct Deque* deque = initializeDeque();\n\n    // Inserting elements at front and rear\n    insertFront(deque, 10);\n    insertFront(deque, 20);\n    insertRear(deque, 30);\n    insertRear(deque, 40);\n\n    // Displaying the deque\n    printf(\"Deque: \");\n    displayDeque(deque);\n\n    // Deleting elements from front and rear\n    deleteFront(deque);\n    deleteRear(deque);\n\n    // Displaying the deque after deletion\n    printf(\"Deque after deletion: \");\n    displayDeque(deque);\n\n    // Freeing allocated memory\n    free(deque);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"education/","title":"<code>Education</code>","text":""},{"location":"education/#srmist-kattankulathur","title":"SRMIST Kattankulathur","text":"<p> <code>2022 - 2026</code> </p> <ul> <li>B.Tech in Electronics and Computer Engineering</li> </ul>"},{"location":"education/#campus-activity","title":"Campus activity","text":"<ul> <li> Physics Project Winner</li> </ul>"},{"location":"education/#sri-chaithanya-techno-school-kr-puram","title":"Sri Chaithanya Techno School Kr-Puram","text":"<p><code>2020 - 2022</code></p> <ul> <li>Class 12th <code>[CBSE]</code></li> <li>Class 11th <code>[CBSE]</code></li> </ul>"},{"location":"education/#vagdevi-vilas-school-varthur","title":"Vagdevi Vilas School Varthur","text":"<p><code>2011 - 2020</code></p> <ul> <li>Class 1st to 10th <code>CBSE</code></li> </ul>"},{"location":"education/#campus-activity_1","title":"Campus activity","text":"<ul> <li> School team football player</li> <li> Participated in multiple intra-school athletics </li> <li> runner up in 4x100 rally <code>2020</code></li> <li> runner up in football <code>2020</code></li> <li> runner up in kabaddi <code>2020</code></li> <li> Kala utsav dance competition 2nd Runner up <code>2020</code></li> </ul>"}]}